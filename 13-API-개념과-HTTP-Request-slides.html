<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>13강: 🤖 에이전트와 통신 시스템</title>
    <style>
        /* === Overflow-safe Global Reset (필수) === */
        *, *::before, *::after { box-sizing: border-box; }
        html, body { max-width: 100%; overflow-x: hidden; }
        :root { scrollbar-gutter: stable both-edges; }

        /* 미디어/테이블이 그리드 밖으로 넘치지 않도록 */
        img, video, svg, canvas, iframe, table { max-width: 100%; height: auto; }
        pre, code, .code-block { max-width: 100%; overflow: auto; }

        /* 그리드 자식이 최소 폭 강제로 늘어나며 넘침을 만드는 문제 방지 */
        .content-grid { min-width: 0; }
        .content-grid > * { min-width: 0; overflow-wrap: anywhere; }

        /* 긴 단어/URL 강제 줄바꿈 */
        .basic-font, .card-title, .header-1, .header-2, .header-3 { overflow-wrap: anywhere; word-break: break-word; }

        /* 유틸리티: 강제 오버플로 방지 박스 */
        .no-overflow { max-width: 100%; overflow: hidden; }

        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #FFFFFF;
            color: #2D3748;
            line-height: 1.6;
        }

        /* 🧭 고정 네비게이션 바 */
        .nav-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid #E2E8F0;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 5vw;
            box-shadow: 0 2px 10px rgba(27, 54, 93, 0.1);
        }

        .nav-logo {
            height: 40px;
            font-size: 24px;
            font-weight: 700;
            color: #1B365D;
        }

        .nav-progress {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 14px;
            color: #636E72;
        }

        .nav-progress .current-slide-title {
            font-weight: 600;
            color: #1B365D;
            max-width: 300px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .nav-progress .slide-counter {
            background: #F8F9FA;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            color: #636E72;
        }

        /* 스크롤 진행률 표시 */
        .scroll-progress {
            position: fixed;
            top: 70px;
            left: 0;
            width: 100%;
            height: 4px;
            background: #F8F9FA;
            z-index: 999;
        }

        .scroll-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #1B365D 0%, rgb(135, 0, 232) 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* 슬라이드 컨테이너 */
        .slide-container {
            width: 100%;
            background: #FFFFFF;
            padding-top: 100px;
        }

        .slide {
            min-height: calc(100vh - 100px);
            width: 100%;
            padding: 32px 5vw 48px 5vw;
            display: flex;
            flex-direction: column;
            text-align: left;
            scroll-margin-top: 100px;
            box-sizing: border-box;
        }

        .slide + .slide {
            border-top: 2px solid #F8F9FA;
        }


        /* Center alignment for intro slide */
        .slide.intro {
            text-align: center;
            justify-content: center;
        }

        .slide.intro .header-1,
        .slide.intro .header-2 {
            text-align: center;
        }

        /* 타이포그래피 */
        .header-1 {
            font-size: 21pt;
            font-weight: 700;
            color: #1B365D;
            margin-bottom: 12px;
            line-height: 1.2;
            text-align: center;
        }

        .header-2 {
            font-size: 18pt;
            font-weight: 600;
            color: #1B365D;
            margin-bottom: 9px;
            line-height: 1.3;
        }

        .header-3 {
            font-size: 15pt;
            font-weight: 600;
            color: #1B365D;
            margin-bottom: 6px;
            line-height: 1.3;
        }

        .basic-font {
            font-size: 13pt;
            color: #2D3748;
            line-height: 1.3;
            margin-bottom: 8px;
        }

        .message {
            font-size: 15pt;
            font-weight: 500;
            color: rgb(115, 113, 113);
            margin-bottom: 6px;
            line-height: 1.3;
            text-align: left;
        }

        /* 콜아웃 */
        .callout-center {
            text-align: center;
            background: #ffffff;
            border: 1px solid rgba(27, 54, 93, 0.12);
            border-radius: 14px;
            padding: 20px 24px;
            margin: 24px auto;
            width: fit-content;
            box-shadow: 0 4px 16px rgba(27, 54, 93, 0.08), 0 1px 3px rgba(27, 54, 93, 0.06);
        }

        .callout {
            padding: 16px;
            margin: 8px auto;
            background: rgba(178, 73, 234, 0.04);
            border: 0px;
            text-align: left;
            width: 100%;
            border-radius: 8px;
            font-size: 13pt;
            line-height: 1.7;
        }

        /* 콘텐츠 카드 */
        .content-card {
            background: #FFFFFF;
            border: 1px solid rgb(235, 226, 240);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 8px;
            box-shadow: 0 2px 8px rgba(27, 54, 93, 0.05);
            transition: all 0.2s ease;
            margin-top: 0px;
        }

        .content-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(27, 54, 93, 0.1);
        }

        .card-title {
            font-size: 15pt;
            font-weight: 600;
            color: #1B365D;
            margin-bottom: 12px;
            margin-top: 6px;
            text-align: left;
        }

        /* 그리드 시스템 */
        .content-grid {
            display: grid;
            gap: 8px;
            margin: 12px 0;
        }

        .content-grid-2 {
            grid-template-columns: 1fr 1fr;
        }

        .content-grid-3 {
            grid-template-columns: repeat(3, 1fr);
        }

        /* 리스트 스타일 */
        .step-list {
            list-style: none;
            counter-reset: step-counter;
            margin: 12px 0;
            padding-left: 0;
        }

        .step-list > li {
            counter-increment: step-counter;
            margin-bottom: 10px;
            padding-left: 36px;
            position: relative;
            line-height: 1.2;
            font-size: 12pt;
        }

        .step-list > li::before {
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 0;
            background: rgba(114, 29, 171, 0.7);
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12pt;
            font-weight: 600;
        }

        .checklist {
            list-style: none;
            margin: 12px 0;
            padding-left: 0;
        }

        .checklist li {
            padding: 4px 0 4px 26px;
            position: relative;
            margin-bottom: 0px;
            line-height: 1.2;
            font-size: 12pt;
        }

        .checklist li::before {
            content: "✓";
            position: absolute;
            left: 0;
            color: rgba(114, 29, 171, 0.7);
            font-weight: bold;
            font-size: 12pt;
        }

        /* 코드 블록 */
        .code-block {
            background: #F8F9FA;
            border: 1px solid #E2E8F0;
            border-radius: 8px;
            padding: 8px 12px;
            margin: 8px 0;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 10pt;
            color: #2D3748;
            overflow-x: auto;
            line-height: 1.4;
        }

        /* 테이블 */
        .content-table {
            width: 100%;
            border-collapse: collapse;
            margin: 12px 0;
            background: #FFFFFF;
            border: 1px solid #E2E8F0;
            border-radius: 8px;
            overflow: hidden;
            font-size: 12pt;
        }

        .content-table th {
            background: #F8F9FA;
            padding: 8px 8px;
            font-size: 15pt;
            font-weight: 600;
            color: #1B365D;
            text-align: left;
            border-bottom: 2px solid #E2E8F0;
        }

        .content-table td {
            padding: 8px 8px;
            color: #2D3748;
            border-bottom: 1.5px solid #F8F9FA;
            text-align: left;
            vertical-align: top;
        }

        .content-table tr:last-child td {
            border-bottom: none;
        }

        .content-table tr:hover {
            background: rgba(178, 73, 234, 0.05);
        }

        /* 강조 스타일 */
        .text-emphasis {
            color: #1B365D;
            font-weight: 600;
        }

        .text-highlight {
            background: rgba(178, 73, 234, 0.04);
            padding: 2px 6px;
            border-radius: 4px;
            color: #1B365D;
        }

        /* 부드러운 스크롤 */
        html {
            scroll-behavior: smooth;
        }

        /* 반응형 */
        @media (max-width: 768px) {
            .content-grid-2,
            .content-grid-3 {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .slide {
                padding: 16px 3vw 32px 3vw;
            }
            
            .nav-progress .current-slide-title {
                display: none;
            }
            
            .header-1 { font-size: 22pt; }
            .header-2 { font-size: 17pt; }
            .header-3 { font-size: 15pt; }
            .basic-font { font-size: 13pt; }
        }

        /* 코드 블록 전용 스타일 - 향상된 라인 브레이크 지원 */
        .code-block {
            background: #F8F9FA;
            border: 1px solid #E2E8F0;
            border-radius: 8px;
            padding: 12px 16px;
            margin: 12px 0;
            font-family: 'Monaco', 'Menlo', 'Consolas', 'Courier New', monospace;
            font-size: 11pt;
            color: #2D3748;
            line-height: 1.5;
            /* 향상된 라인 브레이크 기능 */
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-all;
            overflow-x: auto;
        }

        /* 인라인 코드 스타일 */
        .inline-code {
            background: #F8F9FA;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', 'Consolas', 'Courier New', monospace;
            font-size: 0.9em;
            color: #1B365D;
            border: 1px solid #E2E8F0;
        }

        /* Mermaid 다이어그램 스타일 */
        .mermaid {
            background: #FFFFFF;
            border: 1px solid #E2E8F0;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            text-align: center;
            overflow-x: auto;
            overflow-y: hidden;
        }

        /* Mermaid 다이어그램 반응형 지원 */
        .mermaid svg {
            max-width: 100%;
            height: auto;
        }
    </style>
    <!-- Mermaid.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js"></script>
</head>
<body>
    <!-- 네비게이션 바 -->
    <nav class="nav-bar">
        <div class="nav-logo">🤖 에이전트와 통신 시스템</div>
        <div class="nav-progress">
            <span class="current-slide-title">🤖 에이전트와 통신 시스템</span>
            <span class="slide-counter">1 / 9</span>
        </div>
    </nav>

    <!-- 스크롤 진행률 바 -->
    <div class="scroll-progress">
        <div class="scroll-progress-bar" id="progress-bar"></div>
    </div>

    <!-- 슬라이드 컨테이너 -->
    <div class="slide-container">
        <!-- 인트로 슬라이드 -->
        <section class="slide intro" id="slide-1">
            <h1 class="header-1">🤖 에이전트와 통신 시스템</h1>
            <h2 class="header-2" style="text-align: center;">에이전트가 외부 인터페이스와 내부 도구들과 소통하는 방법</h2>
            <div class="callout-center">
                <ol class="step-list">
                    <li><strong>외부 인터페이스와 통신 (웹훅)</strong> - 카카오톡, 웹 채팅창, 슬랙 등과 연결</li>
                    <li><strong>내부 도구 호출 시스템 (서브 워크플로우/MCP)</strong> - 에이전트가 필요한 도구 선택</li>
                    <li><strong>통합 에이전트 시스템 구축</strong> - 인터페이스와 도구를 연결하는 통합 시스템</li>
                </ol>
            </div>
        </section>

        <!-- 슬라이드 2: 에이전트의 두 가지 통신 요구사항 -->
        <section class="slide" id="slide-2">
            <h2 class="header-2">🤖 에이전트의 두 가지 통신 요구사항</h2>
            <div class="message">에이전트를 잘 활용하려면 외부에서 에이전트를 호출하는 방법과 에이전트가 도구를 호출하는 방법이 필요합니다.</div>

            <div class="content-grid content-grid-2">
                <div class="content-card">
                    <h3 class="card-title">📞 외부 인터페이스에서 호출 (웹훅 트리거)</h3>
                    <div class="basic-font"><strong>웹훅 = 에이전트를 부르는 트리거</strong></div>
                    <ul class="checklist">
                        <li>외부 인터페이스가 우리 에이전트를 호출</li>
                        <li>카카오톡, 슬랙, 웹 채팅창에서 요청 전송</li>
                        <li>HTTP 요청으로 에이전트 워크플로우 시작</li>
                        <li>24시간 대기하며 요청 수신 가능</li>
                    </ul>

                    <div class="basic-font"><strong>다양한 트리거 방식 비교:</strong></div>
                    <table class="content-table">
                        <tr>
                            <th>트리거 유형</th>
                            <th>활용</th>
                        </tr>
                        <tr>
                            <td>Schedule</td>
                            <td>정해진 시간에 자동 실행</td>
                        </tr>
                        <tr>
                            <td>Manual</td>
                            <td>수동으로 직접 실행</td>
                        </tr>
                        <tr>
                            <td>App Trigger</td>
                            <td>특정 앱 이벤트로 실행</td>
                        </tr>
                        <tr style="background: rgba(178, 73, 234, 0.1);">
                            <td><strong>Webhook</strong></td>
                            <td><strong>외부 시스템에서 HTTP로 호출 (가장 범용적)</strong></td>
                        </tr>
                    </table>

                    <div class="callout">
                        💡 <strong>Webhook의 범용성:</strong> 어떤 시스템에서든 HTTP 요청만 보낼 수 있으면 에이전트를 호출할 수 있어 가장 널리 사용됩니다.
                    </div>
                </div>

                <div class="content-card">
                    <h3 class="card-title">🔧 내부 도구 호출 (서브 워크플로우/MCP)</h3>
                    <div class="basic-font"><strong>에이전트가 도구를 호출</strong></div>
                    <ul class="checklist">
                        <li>에이전트가 상황에 맞는 도구 자동 선택</li>
                        <li>문제 해결을 위한 툴 호출</li>
                        <li>서브 워크플로우로 구현</li>
                        <li>MCP(Model Context Protocol) 활용</li>
                    </ul>

                    <div class="code-block">호출 관계 정리:

외부 인터페이스 → 웹훅 → 에이전트
                           ↓
                    에이전트 → 도구들

• 위쪽: 외부가 에이전트를 호출 (Webhook Trigger)
• 아래쪽: 에이전트가 도구를 호출 (Sub-workflow/MCP)</div>
                </div>
            </div>

            <div class="callout">
                <strong>핵심:</strong> 에이전트는 웹훅으로 외부에서 호출받고, 내부 도구들을 직접 호출하여 문제를 해결합니다. 웹훅은 HTTP 기반이라 가장 범용적으로 사용되는 트리거 방식입니다.
            </div>
        </section>

        <!-- 슬라이드 3: 웹훅과 에이전트 외부 인터페이스 연결 -->
        <section class="slide" id="slide-3">
            <h2 class="header-2">📞 웹훅(Webhook): 이벤트 기반 HTTP Callback</h2>
            <div class="message">웹훅은 "이벤트가 발생했을 때 특정 URL로 HTTP 요청을 자동으로 보내는" 이벤트 기반 통신 방식입니다</div>

            <div class="content-grid content-grid-2">
                <div class="content-card">
                    <h3 class="card-title">🎯 웹훅의 핵심 개념</h3>
                    <div class="basic-font"><strong>정의:</strong></div>
                    <div class="code-block">Webhook = Event 발생 시 자동으로 실행되는 HTTP Callback

"이벤트가 생기면 나를 불러줘(call back)"</div>

                    <div class="basic-font"><strong>일반 API vs 웹훅 차이:</strong></div>
                    <table class="content-table">
                        <thead>
                            <tr>
                                <th>구분</th>
                                <th>일반 HTTP Request</th>
                                <th>Webhook</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>요청 주체</td>
                                <td>내가 필요할 때 요청 (Pull)</td>
                                <td>상대가 이벤트 발생 시 호출 (Push)</td>
                            </tr>
                            <tr>
                                <td>트리거</td>
                                <td>사용자/클라이언트</td>
                                <td>이벤트 (자동)</td>
                            </tr>
                            <tr>
                                <td>통신 방향</td>
                                <td>내가 외부로 요청</td>
                                <td>외부가 나를 호출</td>
                            </tr>
                            <tr>
                                <td>예시</td>
                                <td>API 호출로 결제 상태 조회</td>
                                <td>결제 완료 시 자동 알림</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="content-card">
                    <h3 class="card-title">🔄 웹훅 동작 원리</h3>
                    <div class="basic-font"><strong>4단계 프로세스:</strong></div>
                    <ol class="step-list">
                        <li><strong>Webhook URL 등록</strong><br>
                        "이 주소로 알려줘" - 내 엔드포인트 등록</li>
                        <li><strong>이벤트 발생</strong><br>
                        상대방 시스템에서 이벤트 감지 (예: 결제 완료)</li>
                        <li><strong>자동 HTTP 요청 전송</strong><br>
                        등록된 URL로 POST 요청과 데이터 전송</li>
                        <li><strong>수신 서버 처리</strong><br>
                        요청을 받아 필요한 작업 수행</li>
                    </ol>

                    <div class="basic-font"><strong>실제 예시:</strong></div>
                    <div class="code-block">① 웹훅 등록:
https://myapp.com/webhook/payment

② 이벤트 발생: 사용자 결제 완료

③ 자동 전송:
POST /webhook/payment
{
  "event": "payment.completed",
  "user_id": 12345,
  "amount": 10000
}

④ 내 서버: DB 업데이트, 이메일 발송</div>

                    <div class="callout">
                        💡 <strong>핵심:</strong> 웹훅은 "HTTP Request를 이용한 Callback 메커니즘"입니다. 내가 요청하지 않아도 상대가 이벤트 발생 시 나를 불러주는(call back) 구조입니다.
                    </div>
                </div>
            </div>
        </section>

        <!-- 슬라이드 4: 웹훅 실전 설정 -->
        <section class="slide" id="slide-4">
            <h2 class="header-2">⚙️ 웹훅 설정과 간단한 프론트엔드 연결</h2>
            <div class="message">웹훅을 설정하고 간단한 웹페이지와 연결하여 외부 통신을 구현해보겠습니다.</div>
            
            <div class="content-grid content-grid-2">
                <div class="content-card">
                    <h3 class="card-title">🔧 n8n 웹훅 노드 설정</h3>
                    <ul class="checklist">
                        <li><strong>HTTP Method:</strong> POST (데이터 전송용)</li>
                        <li><strong>Path:</strong> /chat (사용자 정의 경로)</li>
                        <li><strong>Response Mode:</strong> Respond to Webhook</li>
                        <li><strong>Authentication:</strong> None (테스트용)</li>
                    </ul>
                    <div class="code-block">
웹훅 설정 결과:
https://your-n8n.com/webhook/chat

→ 이 주소로 POST 요청하면 워크플로우 시작
                    </div>

                    <div class="basic-font" style="margin-top: 16px;"><strong>연결 코드 예시:</strong></div>
                    <div class="code-block" style="font-size: 9pt;">
// 사용자가 메시지 전송 시
fetch('https://your-n8n.com/webhook/chat', {
  method: 'POST',
  headers: {'Content-Type': 'application/json'},
  body: JSON.stringify({
    message: '문서 분석해줘',
    userId: 'user123'
  })
})
.then(res => res.json())
.then(data => {
  // AI 응답을 화면에 표시
  displayMessage(data.response);
});</div>
                </div>
                
                <div class="content-card">
                    <h3 class="card-title">💬 챗봇 인터페이스 예시</h3>

                    <div class="basic-font"><strong>사용자가 보는 대화 창:</strong></div>
                    <div style="background: #f8f9fa; border: 2px solid #e2e8f0; border-radius: 12px; padding: 16px; margin: 12px 0;">
                        <!-- 챗봇 헤더 -->
                        <div style="background: linear-gradient(135deg, #1B365D, rgb(135, 0, 232)); color: white; padding: 12px; border-radius: 8px 8px 0 0; margin: -16px -16px 12px -16px; font-weight: 600;">
                            🤖 AI 어시스턴트
                        </div>

                        <!-- 메시지 영역 -->
                        <div style="min-height: 120px; background: white; border-radius: 8px; padding: 12px; margin-bottom: 12px;">
                            <!-- 사용자 메시지 -->
                            <div style="text-align: right; margin-bottom: 8px;">
                                <div style="display: inline-block; background: #1B365D; color: white; padding: 8px 12px; border-radius: 12px 12px 0 12px; max-width: 70%; font-size: 11pt;">
                                    문서 분석해줘
                                </div>
                            </div>
                            <!-- AI 응답 -->
                            <div style="text-align: left;">
                                <div style="display: inline-block; background: #f0f0f0; color: #2D3748; padding: 8px 12px; border-radius: 12px 12px 12px 0; max-width: 70%; font-size: 11pt;">
                                    네, 문서를 분석하겠습니다...
                                </div>
                            </div>
                        </div>

                        <!-- 입력창 -->
                        <div style="display: flex; gap: 8px;">
                            <input type="text" placeholder="메시지를 입력하세요..." style="flex: 1; padding: 10px; border: 1px solid #e2e8f0; border-radius: 20px; font-size: 11pt;">
                            <button style="background: rgb(135, 0, 232); color: white; border: none; padding: 10px 20px; border-radius: 20px; cursor: pointer; font-weight: 600;">전송</button>
                        </div>
                    </div>

                    <div class="basic-font"><strong>챗봇 ↔ n8n 연결 구조:</strong></div>
                    <div style="background: #f8f9fa; padding: 16px; border-radius: 8px; margin-top: 12px;">
                        <pre class="mermaid" style="background: transparent; border: none; padding: 0;">
graph LR
    A["💬 챗 인터페이스<br/>(웹/앱)"] -->|"HTTP POST<br/>{message: '문서 분석해줘'}"| B["📞 Webhook Trigger<br/>n8n"]
    B --> C["🤖 AI Agent<br/>처리"]
    C -->|"응답 반환"| A

    style A fill:#e3f2fd
    style B fill:#fff3e0
    style C fill:#f3e5f5
                        </pre>
                    </div>

                </div>
            </div>
            
            <div class="callout">
                <strong>다음 단계:</strong> 이 웹훅이 받은 요청을 내부 워크플로우들과 연결하여 복잡한 처리를 수행할 수 있습니다.
            </div>
        </section>

        <!-- 슬라이드 5: 서브 워크플로우와 에이전트 도구 호출 -->
        <section class="slide" id="slide-5">
            <h2 class="header-2">🔄 서브 워크플로우: 기존 워크플로우를 도구로 재활용</h2>
            <div class="message">서브 워크플로우는 기존에 만든 워크플로우를 하나의 Tool로 활용하는 방식입니다</div>

            <div class="content-grid content-grid-2">
                <div class="content-card">
                    <h3 class="card-title">♻️ 서브 워크플로우의 핵심 가치: 재활용 & 수정 용이성</h3>

                    <div class="basic-font"><strong>복사 없이 재사용:</strong></div>
                    <ul class="checklist">
                        <li><strong>하나의 워크플로우를 여러 곳에서 호출</strong></li>
                        <li>복사할 필요 없이 동일한 워크플로우 참조</li>
                        <li>한 번 만들면 어디서든 Tool로 활용</li>
                    </ul>

                    <div class="basic-font"><strong>동시 업그레이드:</strong></div>
                    <ul class="checklist">
                        <li><strong>원본 워크플로우 수정 시 모든 곳에 즉시 반영</strong></li>
                        <li>각 사용처마다 따로 수정할 필요 없음</li>
                        <li>버전 관리가 단순하고 명확</li>
                    </ul>

                    <div class="basic-font"><strong>독립적 관리:</strong></div>
                    <ul class="checklist">
                        <li>각 워크플로우를 독립적으로 개발/테스트</li>
                        <li>문제 발생 시 특정 워크플로우만 수정</li>
                        <li>복잡한 시스템을 모듈화하여 관리</li>
                    </ul>

                    <div class="callout">
                        💡 <strong>핵심:</strong> 복사 없이 재사용 → 수정 시 모든 곳에 동시 반영 → 유지보수 극대화!
                    </div>
                </div>

                <div class="content-card">
                    <h3 class="card-title">🔗 에이전트 ↔ 워크플로우 N:N 연결 구조</h3>

                    <div class="basic-font"><strong>여러 에이전트가 동일한 워크플로우를 공유:</strong></div>
                    <div style="background: #f8f9fa; padding: 16px; border-radius: 8px; margin: 12px 0;">
                        <pre class="mermaid" style="background: transparent; border: none; padding: 0;">
graph LR
    subgraph Agents["🤖 에이전트들"]
        A1["고객 상담<br/>Agent"]
        A2["문서 분석<br/>Agent"]
        A3["업무 자동화<br/>Agent"]
    end

    subgraph Workflows["⚙️ 서브 워크플로우들"]
        W1["PDF 추출<br/>Workflow"]
        W2["AI 요약<br/>Workflow"]
        W3["이메일 발송<br/>Workflow"]
    end

    A1 -.->|호출| W1
    A1 -.->|호출| W2
    A1 -.->|호출| W3

    A2 -.->|호출| W1
    A2 -.->|호출| W2

    A3 -.->|호출| W2
    A3 -.->|호출| W3

    style A1 fill:#e3f2fd
    style A2 fill:#e3f2fd
    style A3 fill:#e3f2fd
    style W1 fill:#fff3e0
    style W2 fill:#fff3e0
    style W3 fill:#fff3e0
                        </pre>
                    </div>

                    <div class="basic-font"><strong>업그레이드 시나리오:</strong></div>
                    <div class="code-block" style="font-size: 10pt;">
1️⃣ "AI 요약 Workflow" 성능 개선
   → 기존: 3초 소요
   → 개선: 1초 소요

2️⃣ 자동으로 모든 에이전트에 반영
   ✅ 고객 상담 Agent → 1초로 개선
   ✅ 문서 분석 Agent → 1초로 개선
   ✅ 업무 자동화 Agent → 1초로 개선

3️⃣ 수정 횟수: 단 1번!
   (복사 방식이었다면 3번 수정 필요)</div>

                    <div class="basic-font"><strong>장점 요약:</strong></div>
                    <ul class="checklist">
                        <li>N:N 관계로 자유로운 조합</li>
                        <li>워크플로우 1개 수정 = 모든 에이전트 업그레이드</li>
                        <li>중복 코드 제거, 유지보수 효율 극대화</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- 새로운 슬라이드 6: MCP (Model Context Protocol) -->
        <section class="slide" id="slide-6">
            <h2 class="header-2">🔗 MCP (Model Context Protocol): 단순 Tool들의 집합체</h2>
            <div class="message">MCP는 여러 단순 Tool들을 중앙에서 관리하며, Agent가 필요한 Tool들을 선택해 사용하는 구조입니다</div>

            <div class="content-grid content-grid-2">
                <div class="content-card">
                    <h3 class="card-title">🧩 MCP의 구조와 특징</h3>

                    <div class="basic-font"><strong>MCP = 단순 Task들의 집합:</strong></div>
                    <ul class="checklist">
                        <li>파일 읽기, 웹 검색, 데이터베이스 조회 등 단순 Task</li>
                        <li>중앙 MCP 서버가 여러 Tool들을 제공</li>
                        <li>Agent가 상황에 맞는 Tool들을 선택해 사용</li>
                        <li>여러 MCP 및 Tool을 조합하여 업무 자동화</li>
                    </ul>

                    <div class="basic-font"><strong>MCP 사용 패턴:</strong></div>
                    <div class="code-block" style="font-size: 10pt;">
🎯 업무: "최근 뉴스 분석 리포트 작성"

1️⃣ Agent가 단계별 Tool 선택:
   → MCP Tool: 웹 검색
   → MCP Tool: 텍스트 추출
   → MCP Tool: 요약 생성
   → MCP Tool: 파일 저장

2️⃣ 전체 프로세스:
   여러 MCP Tool을 단계별로 조합하여 실행

💡 각 단계마다 적합한 Tool 선택 필요</div>

                    <div class="callout">
                        🔧 <strong>n8n에서도 MCP 활용 가능:</strong> 단순 Task들을 조합한 MCP를 만들 수 있습니다. 다만 n8n에서는 Subworkflow가 더 일반적으로 자주 활용됩니다.
                    </div>
                </div>

                <div class="content-card">
                    <h3 class="card-title">🏗️ Agent ↔ MCP ↔ Tools 구조</h3>

                    <div class="basic-font"><strong>중앙 MCP 서버와 Agent의 관계:</strong></div>
                    <div style="background: #f8f9fa; padding: 16px; border-radius: 8px; margin: 12px 0;">
                        <pre class="mermaid" style="background: transparent; border: none; padding: 0;">
graph TB
    A["🤖 AI Agent<br/>(사용자 요청 분석)"]

    subgraph MCP["🔗 중앙 MCP 서버"]
        M[MCP Protocol]
    end

    subgraph Tools["🛠️ 단순 Tool들"]
        T1["📄 파일 읽기"]
        T2["🌐 웹 검색"]
        T3["💾 DB 조회"]
        T4["📊 데이터 변환"]
        T5["📧 이메일 발송"]
        T6["📝 텍스트 요약"]
    end

    A <-->|"Tool 선택/호출"| M
    M --> T1
    M --> T2
    M --> T3
    M --> T4
    M --> T5
    M --> T6

    style A fill:#e3f2fd
    style M fill:#fff3e0
    style T1 fill:#f3e5f5
    style T2 fill:#f3e5f5
    style T3 fill:#f3e5f5
    style T4 fill:#f3e5f5
    style T5 fill:#f3e5f5
    style T6 fill:#f3e5f5
                        </pre>
                    </div>

                    <div class="basic-font"><strong>실제 동작 흐름:</strong></div>
                    <div class="code-block" style="font-size: 10pt;">
사용자: "프로젝트 문서 분석해줘"

1. Agent가 MCP에 요청
2. MCP가 사용 가능한 Tool 목록 제공
3. Agent가 필요한 Tool 선택:
   ✓ 파일 읽기 Tool
   ✓ 텍스트 요약 Tool
4. 선택된 Tool들을 순차 실행
5. 결과를 조합하여 사용자에게 응답</div>

                    <div class="basic-font"><strong>MCP의 핵심:</strong></div>
                    <ul class="checklist">
                        <li>단순 Task 단위로 Tool 분리</li>
                        <li>Agent가 상황에 맞게 Tool 조합</li>
                        <li>여러 MCP Tool을 단계별로 활용</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- 슬라이드 7: MCP vs 서브 워크플로우 비교 -->
        <section class="slide" id="slide-7">
            <h2 class="header-2">⚖️ MCP vs 서브 워크플로우: 차이점과 선택 기준</h2>
            <div class="message">이번 강의에서는 n8n에서 더 일반적으로 사용되는 서브 워크플로우를 중심으로 다룹니다</div>

            <div class="content-grid content-grid-2">
                <div class="content-card">
                    <h3 class="card-title">🔗 MCP: Task 집합체를 조합</h3>

                    <div class="basic-font"><strong>MCP의 사용 방식:</strong></div>
                    <ul class="checklist">
                        <li><strong>단순 Task 단위:</strong> 파일 읽기, 웹 검색 등</li>
                        <li><strong>단계별 Tool 선택:</strong> Agent가 각 단계마다 Tool 선택</li>
                        <li><strong>여러 MCP 조합:</strong> 전체 프로세스에 따라 MCP 조합</li>
                        <li><strong>동적 실행:</strong> 상황에 맞게 Tool 선택 및 조합</li>
                    </ul>

                    <div class="code-block" style="font-size: 10pt;">
MCP 실행 예시:

사용자: "프로젝트 리포트 작성"

Agent 판단 및 단계별 Tool 선택:
1️⃣ 파일 읽기 Tool (MCP 1)
2️⃣ 데이터 분석 Tool (MCP 1)
3️⃣ 웹 검색 Tool (MCP 2)
4️⃣ 텍스트 요약 Tool (MCP 2)
5️⃣ 파일 저장 Tool (MCP 1)

💡 각 단계마다 적절한 Tool 선택 필요
💡 여러 MCP를 조합하여 전체 업무 수행</div>
                </div>

                <div class="content-card">
                    <h3 class="card-title">🔄 서브 워크플로우: End-to-End 프로세스 실행</h3>

                    <div class="basic-font"><strong>서브 워크플로우의 사용 방식:</strong></div>
                    <ul class="checklist">
                        <li><strong>완전한 프로세스:</strong> 특정 업무의 전체 흐름 정의</li>
                        <li><strong>한 번에 실행:</strong> Agent가 워크플로우 선택 후 그대로 실행</li>
                        <li><strong>독립적 재활용:</strong> 완성된 워크플로우를 여러 곳에서 재사용</li>
                        <li><strong>예측 가능:</strong> 정해진 로직대로 안정적 실행</li>
                    </ul>

                    <div class="code-block" style="font-size: 10pt;">
서브 워크플로우 실행 예시:

사용자: "프로젝트 리포트 작성"

Agent 판단:
→ "문서 분석 리포트 생성" 워크플로우 선택

워크플로우 자동 실행:
✓ 파일 읽기
✓ 데이터 분석
✓ 차트 생성
✓ 리포트 작성
✓ 이메일 발송

💡 워크플로우 1개 선택으로 전체 프로세스 완료
💡 중간 판단 없이 End-to-End 실행</div>
                </div>
            </div>

            <div class="content-grid content-grid-2" style="margin-top: 16px;">
                <div class="content-card">
                    <h3 class="card-title">📊 핵심 차이점 비교</h3>
                    <table class="content-table">
                        <thead>
                            <tr>
                                <th>구분</th>
                                <th>MCP</th>
                                <th>서브 워크플로우</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>단위</td>
                                <td>단순 Task 집합</td>
                                <td>End-to-End 프로세스</td>
                            </tr>
                            <tr>
                                <td>실행 방식</td>
                                <td>단계별 Tool 조합</td>
                                <td>워크플로우 선택 후 일괄 실행</td>
                            </tr>
                            <tr>
                                <td>Agent 역할</td>
                                <td>각 단계마다 Tool 선택</td>
                                <td>워크플로우 선택만</td>
                            </tr>
                            <tr>
                                <td>복잡도</td>
                                <td>동적이고 유연</td>
                                <td>명확하고 예측 가능</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="content-card">
                    <h3 class="card-title">🎯 n8n에서의 선택</h3>

                    <div class="basic-font"><strong>n8n 환경에서:</strong></div>
                    <ul class="checklist">
                        <li><strong>서브 워크플로우 권장:</strong> 기존 워크플로우 재활용에 최적화</li>
                        <li><strong>MCP도 가능:</strong> 단순 Task 조합용 MCP 제작 가능</li>
                        <li><strong>실무 활용:</strong> 서브 워크플로우가 더 일반적으로 사용됨</li>
                    </ul>

                    <div class="callout">
                        📌 <strong>이번 강의 초점:</strong> n8n에서 기존 워크플로우를 재활용하는 서브 워크플로우 방식을 중심으로 학습합니다.
                    </div>
                </div>
            </div>
        </section>

        <!-- 슬라이드 8: 14강 예고 - AI Agent 시스템 통합 -->
        <section class="slide" id="slide-8">
            <h2 class="header-2">📋 14강 예고: 통합 AI Agent 시스템 구축</h2>
            <div class="message">다음 시간에는 지금까지 배운 모든 내용을 종합하여 완전한 에이전트 시스템을 만들어보겠습니다</div>

            <div class="content-card">
                <h3 class="card-title">🔄 전체 시스템 통합 아키텍처</h3>

                <div style="background: #f8f9fa; padding: 16px; border-radius: 8px;">
                    <pre class="mermaid" style="background: transparent; border: none; padding: 0;">
graph TB
    A["💬 사용자<br/>(카카오톡)"] -->|"메시지/파일"| B["📞 Webhook<br/>Request"]

    B --> C["🤖 AI Agent<br/>(업스테이지 LLM)"]

    C -->|"메모리 조회"| M["💭 Memory<br/>(대화 기록)"]
    M --> C

    C -->|"판단: 문서 요약"| D1["📄 Tool 1<br/>파싱 및 요약"]
    C -->|"판단: 정보 저장"| D2["💾 Tool 2<br/>추출 및 저장"]

    D1 --> E["결과 통합"]
    D2 --> E

    E --> F["📤 Response<br/>답변 반환"]
    F --> A

    style A fill:#e3f2fd
    style B fill:#fff3e0
    style C fill:#f3e5f5
    style M fill:#fce4ec
    style D1 fill:#e8f5e9
    style D2 fill:#e8f5e9
    style E fill:#f3e5f5
    style F fill:#fff3e0
                    </pre>
                </div>
            </div>

            <div class="callout">
                🚀 <strong>14강 예고:</strong> 외부 인터페이스(웹훅), AI 에이전트, 내부 도구(서브 워크플로우)를 모두 연결한 종합적인 AI Agent 문서 관리 시스템을 직접 구현해봅니다!
            </div>
        </section>

    </div>

    <script>
        // 스크롤 진행률 업데이트
        function updateScrollProgress() {
            const container = document.documentElement;
            const scrolled = container.scrollTop;
            const maxScroll = container.scrollHeight - container.clientHeight;
            const progress = (scrolled / maxScroll) * 100;
            
            const progressBar = document.getElementById('progress-bar');
            progressBar.style.width = `${Math.min(progress, 100)}%`;
        }

        // 현재 슬라이드 제목 업데이트
        function updateCurrentSlide() {
            const slides = document.querySelectorAll('.slide');
            const scrollTop = window.pageYOffset + 150;
            
            let currentSlide = 1;
            let currentSlideElement = slides[0];
            
            slides.forEach((slide, index) => {
                if (scrollTop >= slide.offsetTop) {
                    currentSlide = index + 1;
                    currentSlideElement = slide;
                }
            });
            
            // Update slide counter
            document.querySelector('.slide-counter').textContent = `${currentSlide} / ${slides.length}`;
            
            // Update current slide title
            const slideTitle = currentSlideElement.querySelector('.header-2');
            if (slideTitle) {
                document.querySelector('.current-slide-title').textContent = slideTitle.textContent.trim();
            }
        }

        // 이벤트 리스너
        window.addEventListener('scroll', () => {
            updateScrollProgress();
            updateCurrentSlide();
        });

        // 초기 실행
        updateScrollProgress();
        updateCurrentSlide();

        // 키보드 네비게이션
        document.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowDown' || e.key === ' ') {
                e.preventDefault();
                window.scrollBy(0, window.innerHeight * 0.8);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                window.scrollBy(0, -window.innerHeight * 0.8);
            }
        });
    </script>
    
    <!-- Mermaid 초기화 스크립트 -->
    <script>
        // Mermaid 설정 및 초기화
        mermaid.initialize({
            startOnLoad: true,
            theme: 'neutral',
            themeVariables: {
                primaryColor: '#1B365D',
                primaryTextColor: '#2D3748',
                primaryBorderColor: '#E2E8F0',
                lineColor: '#636E72',
                backgroundColor: '#FFFFFF',
                secondaryColor: '#F8F9FA',
                tertiaryColor: '#E2E8F0'
            },
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true
            },
            sequence: {
                useMaxWidth: true,
                wrap: true
            }
        });
    </script>
</body>
</html>